---
{"dg-publish":true,"dg-path":"程序语言/为什么需要正则表达式.md","permalink":"/程序语言/为什么需要正则表达式/"}
---

#王垠 #Technomous 

学习 Unix 最开头，大家都学过正则表达式(regexp)。可是有没有人考虑过我们为什么需要正则表达式？

正则表达式本来的初衷是用来从无结构的字符串中提取信息，殊不知这正好是 Unix 的缺陷所在。Unix 用无结构的字符串来表示数据，导致了诸多复杂的基于 regexp 的软件的诞生。sed, AWK, Perl, ... 都是为了同样的目的来到这个世界上的。如果不是因为 Unix 用字符串来表示数据，我们就会拥有按数据结构类型的直接存储，而不需要折腾 regexp。正则表达式有它自己的价值（针对自然语言），但是我们其实不需要把它应用到程序语言和操作系统里面。

正则表达式本身用一个字符串来表示，这带来另外一些问题。因为正则表达式的本质不是字符串，而是一个数据结构。学过计算理论的人可能知道这个数据结构叫做 NFA（nondeterministic finite automaton，非确定性有限自动机）。所有的数据结构应该由程序语言本身来表示，就像用 Java 构造一个对象用 new ClassA("a") 一样。但是正则表达式强迫你把这个简单的构造函数调用写成一个字符串。所以在这个比方之下，你得写成 "new ClassA(\"a\")"。这样当你想要组合这些表达式的时候就发现，正则表达式几乎都是不可组合(compose)的。你几乎不可能把两个 regexp 的变量 A 和 B 安全拼接成一个，比如用 Java 的字符串拼接 A+B。因为你不知道这两个字符串拼在一起之后，那些稀奇古怪的符号会出现什么交叉反应，使得最后的识别的东西根本不是你想要的。

在正则表达式中，由于正则表达式本身的构造函数与数据本身合并到一起，我们不得不对某些“特殊字符”进行 escape。这些特殊字符，其实是用来描述 NFA 的记号，它们属于更高一层的语言。可是在正则表达式里，它们与NFA节点里的字符混为一谈。比如很简单的一个 block comment 的正则表达式，却要写成这个样子：

``` shell
"/\\*([^\\*]|[^/])*\\*/"
```

显然这样的表达式很容易出错。 如果我们用程序语言的表达式来构造这个表达式，它应该是这样：

``` shell
(@... "/*" (@*(@!"*/")) "*/")
```

在这个我自己设计的 Scheme 表达式里，以 `@` 开头的标识符都是构造函数。其中 `@...` 是构造 sequence，`@*` 是构造一个 zero-or-more 的匹配，`@!` 构造一个否定匹配。这个表达式是说：“以 `/*` 开头，接着零个或者多个不是 `*/` 的字符，最后接着一个 `*/。这样一来清晰明了，什么表达式在什么“层次”都很清楚，不需要什么反斜杠 escape，而且这样的表达式可以 compose。比如:

``` shell
(define reg1 (@... "/*" (@* (@! "*/")) "*/"))
(define reg2 (@+ "foo"))
(define reg3 (@= "b"))
```

定义这三个表达式之后，我们之后可以用像 `(@... reg1 (@or reg2 reg3))` 这样的表达式来连接 3 个不同的表达式，构造出更大的表达式。这样的构造可以无限的扩展。从这里以及以往的经验，我总结出一个普遍适用的程序设计的教训：尽量不要把多个层次的语言“压缩”到一层。我们也看到正则表达式与“Unix哲学”有很大关系。我没有考古，所以不知道孰先孰后，但是它们肯定有直接的因果关系。两者都是 Unix 复杂性的来源。